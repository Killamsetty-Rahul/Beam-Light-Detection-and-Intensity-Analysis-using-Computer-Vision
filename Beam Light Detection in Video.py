# -*- coding: utf-8 -*-
"""Beam_Light_Detection_in_Video

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q6aGE-Alge45n0Eidx632QfV7jC0vBtc
"""

from google.colab import drive
drive.mount('/content/drive')

from imutils import contours
from skimage import measure
import numpy as np
# import argparse
import imutils
import cv2
import matplotlib.pyplot as plt

# Make sure Google Drive is mounted
# If not already done in this session, Uncomment the below two lines of code and then run this cell.
# from google.colab import drive
# drive.mount('/content/drive')

video_path = '/content/drive/MyDrive/Beam_light_project/video-2.mp4'
cap = cv2.VideoCapture(video_path)

intensity_threshold = 220
bright_pixel_threshold = 500
max_cluster_size = 20000
min_cluster_size = 300

plt.ion()  # Enable interactive mode for real-time updates

while True:
    ret, frame = cap.read()

    if not ret:
        print("Video processing completed.")
        break

    frame_resized = imutils.resize(frame, height=500)
    gray = cv2.cvtColor(frame_resized, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (11, 11), 0)

    thresh = cv2.threshold(blurred, 200, 255, cv2.THRESH_BINARY)[1]
    thresh = cv2.erode(thresh, None, iterations=2)
    thresh = cv2.dilate(thresh, None, iterations=4)

    labels = measure.label(thresh, connectivity=2, background=0)
    mask = np.zeros(thresh.shape, dtype="uint8")

    beamlight_decrement_needed = False

    for label in np.unique(labels):
        if label == 0:
            continue
        labelMask = np.zeros(thresh.shape, dtype="uint8")
        labelMask[labels == label] = 255
        numPixels = cv2.countNonZero(labelMask)
        if min_cluster_size <= numPixels <= max_cluster_size:
            mask = cv2.add(mask, labelMask)

    cnts = cv2.findContours(mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    if cnts:
        cnts = contours.sort_contours(cnts)[0]

    for (i, c) in enumerate(cnts):
        (x, y, w, h) = cv2.boundingRect(c)
        ((cX, cY), radius) = cv2.minEnclosingCircle(c)
        cv2.circle(frame_resized, (int(cX), int(cY)), int(radius), (0, 0, 255), 3)
        cv2.putText(frame_resized, "#{}".format(i + 1), (x, y - 15), cv2.FONT_HERSHEY_SIMPLEX, 0.45, (0, 0, 255), 2)

        mask = np.zeros(gray.shape, dtype="uint8")
        cv2.drawContours(mask, [c], -1, 255, -1)

        mean_val = cv2.mean(gray, mask=mask)[0]
        bright_pixels = cv2.countNonZero(mask)

        print(f"Cluster #{i+1}: Intensity = {mean_val:.2f}, Bright Pixels = {bright_pixels}")

        if mean_val > intensity_threshold and bright_pixels > bright_pixel_threshold:
            beamlight_decrement_needed = True

    if beamlight_decrement_needed:
        print("Beamlight decrement is required.")
    else:
        print("No dim and dip required, continue your journey. Drive safe.")

    # Display the frame using matplotlib
    plt.clf()
    plt.figure("Frame")
    plt.imshow(cv2.cvtColor(frame_resized, cv2.COLOR_BGR2RGB))
    plt.axis("off")
    plt.pause(0.001)

    # Plot the grayscale histogram
    plt.figure("Grayscale Intensity Histogram")
    plt.clf()
    plt.title("Grayscale Intensity Histogram")
    plt.xlabel("Grayscale Intensity Value")
    plt.ylabel("Pixel Count")
    plt.hist(gray.ravel(), bins=256, range=(0, 256), color='black')
    plt.xlim([0, 256])
    plt.pause(0.001)

cap.release()
plt.close("all")

